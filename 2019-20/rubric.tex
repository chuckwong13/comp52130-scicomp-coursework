\documentclass[a4paper]{article}

\usepackage[margin=3cm]{geometry}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,positioning,fit,decorations.pathreplacing,arrows,calc}
\usepackage{graphicx}
\usepackage{cleveref}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{subcaption}
 \usepackage[doi=true,
 url=false,
 sorting=ydnt,
 maxnames=10,
 backend=biber,
 isbn=false,
 giveninits=true,
 defernumbers=true]{biblatex}
\usepackage{minted}


\bibliography{papers.bib}


\title{Performance analysis and optimisation of matrix-matrix multiplication}

\author{Lawrence Mitchell\thanks{lawrence.mitchell@durham.ac.uk}}

\begin{document}
\maketitle

This assignment is to be completed and handed in via DUO. 
For deadlines, please consult DUO and the level handbook.

\section{Introduction}
\label{sec:introduction}
Matrix-matrix multiplication is at the core of much of scientific
computing. In this coursework you will study, and improve the
performance of, this core computational kernel for the case of dense
matrix-matrix multiplication. You are provided with a template code
that implements the operation
\begin{equation}
  \label{eq:1}
  C = C + A B
\end{equation}
where $C \in \mathbb{R}^{m \times n}$, $A \in \mathbb{R}^{m \times k}$,
and $B \in \mathbb{R}^{k \times n}$ are rectangular matrices.

\subsection{The BLIS approach to matrix-matrix multiplication}
\label{sec:blis}

The provided code implements the loop blocking scheme developed by
Kazushigo Goto, Robert van der Geijn and co-workers in the BLIS
(BLAS-like Library Instantiation Software) framework. It is described
in two papers: \textcite{Goto:2008} and \textcite{Zee:2015}. The na{\"i}ve
implementation of matrix-matrix multiplication uses three nested
for-loops.
\begin{minted}{c}
for (j = 0; j < n; j++)
  for (p = 0; p < k; p++)
    for (i = 0; i < m; i++)
      c[i, j] = c[i, j] + a[i, p] * b[p, j];
\end{minted}
This implementation of the algorithm, however, exhibits poor spatial
and temporal locality, and is not amenable to vectorisation. The BLIS
approach performs a particular loop-tiling that effectively blocks for
all levels of the memory hierarchy. The innermost loop is a
``microkernel'' that must be tuned to each architecture in turn.


\subsection{Building the code}
\label{sec:build}

The code is provided as a number of C and header files, along with a
\texttt{Makefile} to build the executable. After unpacking the code,
you should see the following files
\begin{minted}{sh}
cflags.mk
gemm.c
Makefile
optimised-gemm.c
parameters.h
\end{minted}

To build the executeable, type \texttt{make}.
\begin{minted}{sh}
# unpack code
$ tar zxvf code.tgz
$ cd code
$ make
\end{minted}
This creates an executable \texttt{gemm}. Running it provides guidance
on usage
\begin{minted}{sh}
$ ./gemm
Invalid arguments.
Usage: ./gemm M N K mode
Where M, N, and K are the dimensions of the problem.
'mode' is one of BENCH or CHECK
\end{minted}

To change parameters, edit \texttt{parameters.h} and use
\texttt{make} again to rebuild. To change optimisation flags to the
compiler, edit \texttt{cflags.mk} and use \texttt{make} to rebuild.

\subsection{Task specification}
\label{sec:task}
The provided implementation implements the loop structure correctly, but
does not have optimal values for the loop blocking parameters.
There are five parameters to tune:

\begin{enumerate}
\item \texttt{MR} and \texttt{NR} control the size of the inner-most
  micro-kernel loops. These should be chosen quite small, so that the
  computation fits in registers.
\item \texttt{MC}, \texttt{KC}, and \texttt{NC} control the sizes of
  the blocks that are streamed from main memory into levels of the
  cache. The BLIS papers provide some guidance on how to choose these
  appropriately.
\end{enumerate}

Your goal is to choose a set of parameters that achieves good
performance for this algorithm over a range of matrix sizes
(controlled by the \texttt{M}, \texttt{N}, and \texttt{K} arguments to
the executable).

You should justify why you think the performance you have achieved is
good by reference to an appropriate \emph{performance model}. The main
aim is to show that you understand how to use an apply the tools and
models seen in the course. You should do so by writing a short report
(no more than 3 pages) describing your choice of 

\section{Marks}
\label{sec:marks}

There are in total 100 marks for the coursework, they
will be awarded as follows:

\begin{center}
  \renewcommand\tabularxcolumn[1]{m{#1}}
  \begin{tabularx}{0.9\linewidth}{Xc}
    \toprule
    Descriptor                                                  & Marks \\
    \midrule
    Demonstration of use of tools                               & 25    \\
    Appropriate use of performance model(s)                     & 15    \\
    Quality of writing                                          & 15    \\
    Quality of presentation of data                             & 15    \\
    \midrule
    Performance of chosen set of parameters as fraction of peak & 30    \\
    \midrule
    Total                                                       & 100   \\
    \bottomrule
  \end{tabularx}
\end{center}

\subsection{Submission details}
\label{sec:submission}

You should submit the following via DUO.
\begin{itemize}
\item \textbf{Report (max 3 pages)}
  detailing your approach to the problem and evaluating the
  performance of your solution (includes performance analysis).
  Provide any illustrative figures or tables of the performance data
  that you collected, demonstrating that you have achieved the goal of
  a fast sparse matrix-matrix multiply.

  \textbf{This document \emph{must} be submitted as a PDF}.

\item \textbf{Full program source code} for your solution to
  \cref{sec:level-4-students}.  This should be provided as a tarball
  of all the relevant project files.  Ensure that your submission
  meets the functional requirements of \cref{sec:requirements-l4}.
\end{itemize}
\printbibliography

\end{document}
